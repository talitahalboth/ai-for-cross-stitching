# -*- coding: utf-8 -*-
"""How to use template matching with OpenCV? | Python

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/learn-ai-python/OpenCV-Tutorials/blob/main/Template_Matching/How_to_use_template_matching_with_OpenCV%3F_%7C_Python.ipynb

# OpenCV template matching
Hi! In this my new video we're going to learn how to use template mathing from OpenCV library.
For this task we need two images - the first one with template and the second one with the target image.
So, let's start!
"""

import os
import sys
import itertools
import cv2
import numpy as np
from matplotlib import pyplot as plt

sys.path.append('../geneticAlgorithm')

from geneticAlgorithm.genetic_algorithm import genetic_algorithm
from geneticAlgorithm.tsp import TSP


def removeCoordinatesClose(input_list, threshold=(10, 10)):
    combos = itertools.combinations(input_list, 2)
    points_to_remove = [point2
                        for point1, point2 in combos
                        if
                        abs(point1[0] - point2[0]) <= threshold[0] and abs(point1[1] - point2[1]) <= threshold[1]]
    points_to_keep = [point for point in input_list if point not in points_to_remove]
    return points_to_keep


def drawPath(problem, permutation, shortestHamPath=True):
    coords = []

    splitPermutation = permutation.index(len(permutation) - 1)
    firstHalf = permutation[:splitPermutation]
    secondHalf = permutation[splitPermutation:]
    permutation = secondHalf + firstHalf
    for i in permutation:
        if problem.coords[i] != [-1, -1]:
            coords.append(problem.coords[i])
    if not shortestHamPath:
        coords.append(problem.coords[permutation[0]])
    xs, ys = zip(*coords)  # create lists of x and y values
    plt.plot(xs, ys, marker='o')


def matchTemplate(fileName, dir_name):
    img = cv2.imread(dir_name+"/img.png")
    # convert it from BGR to RGB
    imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    # and convert it from BGR to GRAY
    imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    template = cv2.imread(dir_name+"/templates/"+fileName, 0)

    # then we get the shape of the template
    w, h = template.shape[::-1]

    # So, we take our image, our template and the template matching method
    res = cv2.matchTemplate(imgGray,
                            template,
                            cv2.TM_CCOEFF_NORMED)

    threshold = 0.9
    # then we get the locations, that have values bigger, than our threshold
    loc = np.where(res >= threshold)

    # remove points too close to each other, likely the same image matched twice
    newPoints = removeCoordinatesClose(list(zip(*loc[::-1])))

    tspFileName = "teste.tsp"
    f = open(tspFileName, "w")

    f.write("NAME: " + fileName + '\n')
    f.write("TYPE: TSP" + '\n')
    f.write("DIMENSION: " + str(len(newPoints)) + '\n')
    f.write("EDGE_WEIGHT_TYPE: EUC_2D" + '\n')
    f.write("NODE_COORD_SECTION" + '\n')
    index = 1
    for pt in newPoints:
        f.write(" ".join([str(index), str(pt[0] + w / 2), str(pt[1] + h / 2)]) + '\n')
        index += 1
        cv2.rectangle(imgRGB,
                      pt,
                      (pt[0] + w, pt[1] + h),
                      (230, 0, 255),
                      1)
    f.write("EOF" + '\n')
    f.close()
    problem = TSP(tspFileName)
    path, history = genetic_algorithm(problem)

    fig = plt.figure(figsize=(10, 10))
    plt.imshow(imgRGB, alpha=0.4)
    drawPath(problem, path)
    plt.savefig(dir_name+'/paths/' + fileName)
    plt.close('all')


directory = "starryNight"
entries = os.listdir(directory + "/templates/")

if not os.path.isdir(directory + "/paths/"):
    # if the demo_folder2 directory is
    # not present then create it.
    os.makedirs(directory + "/paths/")
files = os.listdir(directory + "/paths/")
for f in files:
    os.remove(f)

for entry in entries:
    matchTemplate(entry, directory)
